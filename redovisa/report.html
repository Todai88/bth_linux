<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8">
<title>Redovisning av kursmoment i kursen javascript1</title>
<link rel="stylesheet" href="../style/style.css">
<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>

<body>

    <div class="container">
    <h2 class="text-center"> Redovisningar </h2>
    <p><strong>Nedan ser ni alla mina redovisningar. </strong></p>
    <div class="panel-group" id="redovisnings-grupp">
    <div class="panel panel-default">
    <div class="panel-heading">
    <h4 class="panel-title">
    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom01">Kmom01</a>
    </h4>
    </div>

    <div id="Kmom01" class="panel-collapse collapse">
    <div class="panel-body">
    <div class="row">
    <ul>
    <li><b>Vilken utvecklingsmiljö använder du?</b></li>
    Jag sitter i den föreslagna redovisningsmiljön; <b>Debian Jessie</b> med de tidigare tillämpade utvecklingsverktygen (Atom / Sublime).
    Dock använder jag mig utav VMWare för att virtualisera debian lokalt, och servern har en egen nätverksadapter (alltså använder den inte NAT), utan
    en extern nätverksadapter som jag annars använder vid package-sniffing med Kali-linux.<br><br>

    Utöver det så har jag även skaffat mig en trial-version av DigitalOcean, med vilken jag använder den huvudsakliga delen av min utveckling.
    Detta innebär alltså att min kod är i 'molnet'.<br>
    Ip-addressen till min debian-burk är <b>178.62.110.17</b>.

    <br><br>
    <li><b>Asciinema</b></li>

    Asciinema är hostad här: <a href="http://asciinema.org/a/ek2n56k98088uf8hpzy2wy571"> http://asciinema.org/a/ek2n56k98088uf8hpzy2wy571 </a>
    <br>

    Jag använde min virtualizerade burk för att spela in videon.
    <br><br>
    <li><b>Är du sedan tidigare bekant med Unix, Linux, Debian och / eller terminalen? </b></li>
    Jovars, lite erfarenhet med terminalen och diverse *nix system har jag. Dock har jag inte jobbat med Debian tidigare. Men det känns ju
    väldigt likt Ubuntu, så det bör inte vara något större problem. <br>
    Det är även väldigt intressant att jobba med DigitalOcean dropleten jag satt upp. Jag har som sagt jobbat med terminalen tidigare,
    men aldrig uteslutande med terminalen. Man har alltid haft en GUI att falla tillbaka på. Men det känns grymt kul att leka runt med!
    <br><br>

    <li><b>Hur känns det med Unix-kommandon på terminalen, är det udda eller bekvämt? </b></li>
    Hittils har det inte varit några konstigheter. Tidigare arbete med *nix har varit allt från signalspaning (wifi, blåtand) till att
    jobba med imageprocessing, så det är betydligt mycket mer avancerat än vad vi jobbar med just nu. <br>
    Dock, som nämnt ovan, så är det
    riktigt intressant att jobba mot en webserver!<br><br>
    <li><b>Valde du att köra standard med VirtualBox och Debian eller hur gjorde du?</b></li>
    Som nämnt ovan så har jag valt att köra på en lokal version där jag har Debian Jessie virtualiserat på en VMWare-pro workstation (courtesy of work!).
    Den kommer jag väl antagligen köra mindre på, medans jag kommer fortsätta mig fram med min DigitalOcean droplet, då det är både roligare och mer
    lärorikt!
    <br><br>
    <li><b>Var det något som krånglade eller tog extra mycket tid?</b></li>
    Jag tror de flesta som kommit igång med denna uppgift kan ha fastnat lite lätt i cowsay. Inte för att det är krångligt
    per-se, utan för att *nix system ibland kan vara lite bråkiga. Nästan lite som att jobba med ett illvilligt barn som
    inte riktigt vill göra som man säger åt denne.<br>
    Så ja, i mitt fall så fastnade jag i en minut eller två med just min cowsay då den inte ville hitta kommandot.
    Detta eftersom det saknades en path-variabel i .bash_profile.<br><br>
    </ul>
    </div>
    </div>
    </div>
    </div>
    <div class="panel panel-default">
    <div class="panel-heading">
    <h4 class="panel-title">
    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom02">Kmom02</a>
    </h4>
    </div>
    <div id="Kmom02" class="panel-collapse collapse">
    <div class="panel-body">
    <ul>
        <li><b>Hur känns konceptet med Apache name-based Virtual Hosts? Känner du igen det sedan tidigare?</b></li>
        <br>
        Helt ärligt? Riktigt bra. Har aldrig någonsin jobbat med apache på den här nivån tidigare,
        så det känns riktigt fräckt! Oerhört roligt att lära sig lite nya grejor.
        I början kändes det lite läskigt att arbeta med, men när man börjar förstå konceptet (koncepten),
        så är det riktigt givande. Precis som vilken annan programmering som helst, egentligen.

        Hela den här kursen är egentligen fullkomligt ny för mig, vilket är riktigt trevligt. Jag har varken
        jobbat med apache, bash (shell) eller tmux. :)
        <br><br>
        <li><b>Det blir allt fler kommandon i terminalen, hur känns det med terminalen och dess kommandon?</b></li>
        <br>
        Det känns alltför bra egentligen. Jag gillar att vi börjar slänga på fler options i kommandona,
        skönt att vi börjar binda ihop kursen med sys.opt från python-kursen. Det känns liksom lite mer
        som att man får en helhetsbild. Eller det tror jag iaf att de andra, mer oerfarna studenterna
        kan tycka.

        Det är också underbart att man börjar bli lite mer varm i kläderna kring terminalen. Jag vill
        bryta mig in i penetrationstestande och har länge känt att en av mina svagheter är just specifikt
        att jag inte är alltför van vid övergripande (och detaljerade) kommandon kring alltifrån
        privilige-escalation, etc.

        <br><br>

        <li><b>Gick det bra med ssh-nycklar och rsync över ssh?</b></li>
        <br>
        Yes, inga konstigheter där. Det var väl lite krångligt när jag började med rsync, men det löste sig rätt snabbt.
        Överlag så måste man ju säga att de flesta kommandon är andra lik, så att säga. Med det vill jag alltså säga
        att det gick rätt snabbt att komma igång med kommandon och options iom att de flesta options
        är desamma mellan kommandona.
        <br><br>

        <li><b>Hur kändes det att jobba med tmux?</b></li>
        <br>
        Det var tveklöst den lättare av de aspekterna vi fick lära oss i detta moment.
        Det  var även tveklöst det mest användbara. Det var inte helt ovanligt att jag
        hade nära tre olika terminalfönster öppna via tmux.
        <br>
        Inlärningskurvan var inte alltför farlig heller. Man lärde sig rätt snabbt hur
        man skulle jobba med tmux och när man väl förstod det, så märkte man direkt hur
        mycket ens produktivitet ökade.


    </ul>
    </div>
    	</div>
    	</div>
        			<div class="panel panel-default">
    				    <div class="panel-heading">
    					    <h4 class="panel-title">
    					    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom03">Kmom03</a>
    					    </h4>
    				    </div>
    				    <div id="Kmom03" class="panel-collapse collapse">
    				    	<div class="panel-body">
    				    			<ul>
                                        <li> Tittade du på videoserien? Vad tyckte du om den? </li>
                                        <br>
                                        Nej, inte denna gången! Jag reserverar videor för när jag antingen är på gymmet,
                                        eller när jag verkligen har svårt att förstå ett koncept - alltså när jag
                                        behöver visuell hjälp för att förstå något.
                                        <br>
                                        Istället använder jag mig av min programmeringskunskap för att skriva scripten och
                                        komplementerar med <b>man</b> samt kopiöst googlande för att hitta
                                        hjälp med specifika saker.
                                        <br><br>
                                        <li> Är detta din första bekantskap med skriptprogrammering och Bash? </li>
                                        <br>
                                        Yes. Jag har varken använt mycket skriptprogrammering eller bash tidigare.
                                        Iom att jag håller på att lära mig mer om penetrationstesting så försöker jag verkligen att
                                        lära mig mer och mer om bash och vi / vim.
                                        <br>
                                        Andra skriptprogrammeringsspråk jag lekt med är Python, PHP och väldigt lite Perl. Nu
                                        använder samtliga av dem en interpretor, men överlag anses dem som skriptspråk.
                                        <br><br>
                                        <li> Vilka möjligheter/utmaningar ser du med denna typen av skriptprogrammering? </li>
                                        <br>
                                        Möjligheter? Massor! Som nämnt ovan så vill jag börja jobba med penetrationstesting och jag vet
                                        att bash/perl scriptande är väldigt meriterande. Man kan ju automatisera så många saker också, vilket
                                        gör att man kan utveckla egna payloads som antingen använder sig av embeddade python-scripts eller
                                        som kan användas som rena bash-script.
                                        <br>
                                        Utmaningar? Huvudaskligen kan jag väl tycka att en stor utmaning med skriptprogrammering i bash
                                        kräver att man har särskilda paket installerade för att kunna använda dem, istället för att man
                                        när man exempelvis använder sig av c# har tillgång till ett baspaket av bibliotek som kan användas
                                        för de vanligaste sakerna.
                                        Det ska även nämnas att bash i regel kan ses som ett svårare språk att lära sig mot ett interpreterat språk
                                        som Python.
                                        <br><br>
                                        <li> Hur många poäng fick du i uppgiften med irc-loggfilen? </li>
                                        <br>
                                        Samtliga, självklart!
                                        De var utmanande, men väldigt lärorika! Speciellt uppgifterna när man nestade grep!
                                        <br><br>
                                        <li> Gjorde du extrauppgiften? </li>
                                        <br>
                                        Självklart! Inte gjorde jag bara extrauppgiften, utan jag utvecklade mitt eget factors-script!
                                        Det jag menar med det är att jag alltså skapat ett script som gör allt som det definierade
                                        <b>factor</b> commandot gör.<br>
                                        Mitt script kan ni hitta på <b><a href="https://github.com/Todai88/bth_linux/blob/master/kmom03/commands/commands.bash">här!</a></b>
                                        <br><br>
                                        <li> Var det något som var extra svårt eller utmanande i uppgifterna? </li>
                                        <br>
                                        Hum... Inget var <b><u>riktigt</u></b> svårt, utan vissa delar var väl något svårare.
                                        Exempelvis mitt lilla 'extra'-jobb med factor-scriptet var väl något som kan ses som en svårare del av momentet.
                                        Annars var det väl vissa delar av labben lite utmanande, men inte svårt per-se. Jag gillade labben skarpt, dock!
                                        Den var oerhört lärorik för mig som vill kunna arbeta mig igenom stora textfiler för att hitta information snabbt.
                                        Jag kan tänka mig att det kan vara oerhört bra att kunna arbeta med om man ska läsa igenom access/error-logs för att
                                        antingen hitta oönskad traffik eller rensa ens traffik för att dölja ens språk under en attack.

    				    		   </ul>
    			    		</div>
        				</div>
        			</div>

        			<div class="panel panel-default">
    				    <div class="panel-heading">
    					    <h4 class="panel-title">
    					    <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom04">Kmom04</a>
    					    </h4>
    				    </div>
    				    <div id="Kmom04" class="panel-collapse collapse">
    				    	<div class="panel-body">
    				    			<ul>
                                        <li>Är detta din första bekantskap med JavaScript på servern eller har du testat det tidigare?</li>

                                        Inte riktigt, jag har tidigare skrivit lite småscript - men absolut inget som jag riktigt kan säga är i närheten av hur mycket vi gjort i denna kurs. :)
                                        Det har varit oerhört lärorikt, dock. Jag har, som många av er vet sedan tidigare, lekt lite med penetrationstestande och har även gjort
                                        en hel del moduler från FreeCodeCamp - vilka oftast sköts i JavaScript. Jag har även gått igenom er JavaScripts-kurs, så jag har ju
                                        lite erfarenhet av JS - dock inte på server-sidan. Det jag försöker komma fram till är att jag verkligen uppskattar språket mer och mer ju mer jag
                                        jobbar med det och jag förstår verkligen varför det anses vara ett viktigt språk att lära sig.
                                        Som ni även vet så försöker jag ju bryta mig in i säkerhetsbranschen, vilken inte riktigt ser på javascript som ett viktigt språk att lära sig.
                                        Dock så känner jag att det kan tänkas vara viktigare och viktigare att lära sig språket då det både exekveras på server och klient-sidan nu!

                                        <li>Vad tänker du om ECMA6, dess nya funktioner och sättet att få tillgång till dem via babel-node?</li>

                                        Jag diggar ECMA6 skarpt! Jag har aldrig riktigt jobbat med den nyare versionen av JS tidigare, så detta är verkligen första gången jag uttryckligen jobbar
                                        med något jag aldrig jobbat eller lekt med tidigare. I tidigare moduler har jag alltid haft någon slags bakgrund i språken eller frameworksen.
                                        Men som vanligt sköts det så jäkla bra av dbwebb och lärarlaget; kursen verkar vara upplaggd på ett oerhört bra sätt! :)

                                        Jag förstår verkligen varför babel-node är nödvändigt; många av delarna av ECMA6 är ju inte färdigt tillgängliga i JS. Dvs att det kan krävas
                                        en slags transpilator eller en wrapper för att översätta din ECMA6 kod till ECMA5 på ett sätt där du kan använda dig av ECMA6 som det är tänkt,
                                        men koden exekveras via ECMA5.

                                        <li> Hur gick det att förstå koncepten kring klient och server? </li>

                                        Det gick bra! Jag har, som många på forumet och på gitter vet, använt mig av bash för att verkligen LÄRA mig koncepten kring hur man ska
                                        strukturera scriptspråket.
                                        Sen, som ni vet, så har jag använt mig huvudaskligen av min server (Digital Ocean Debian Droplet), så det känns ännu klarare att det finns en
                                        gräns mellan de två delarna. Jag skriver och exekverar alltså min server på dropleten och skriver och exekverar mina klienter på min maskin och kör dem via
                                        CygWin, alltså RIKTIGT simpla saker egentligen.
                                        Jag kan dock förstå hur det kan tänkas vara lite halvsvårt att förstå hur avgränsningarna fungerar utifall du inte har tillgång till en extern server (alltså om du
                                        kör en virtualisering).

                                        <li> Är du bekant med begreppet funktionell programmering och har du några tankar kring det? </li>

                                        Yes, absolut! Jag har ju studerat programmering i ett bra tag nu och haft en hel del diskussioner kring utifall det verkligen är funktionell programmering
                                        man kör i JavaScript. Jag förstår verkligen varför folk tycker att funktionell programmering är tanken att man huvudsakligen jobbar med funktioner,
                                        alltså bryter upp sin kod i mindre funktioner för att göra koden mer maintainable och readable.
                                        Dock håller jag VERKLIGEN inte med om att det är ett funktionellt språk och jag vet att många inte håller med om det.
                                        Ett bra funktionellt språk är Erlang, eller många av de ML (Moscow ML exempelvis) som finns.

                                        <li> Löste du extrauppgiften? </li>

                                        Yes, det gjorde jag! Detta genom att bryta upp min pid-logik i utility_pid och routes i utility_routes! :)
    				    		   </ul>
    			    		</div>
        				</div>
        			</div>

    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title">
            <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom05">Kmom05</a>
            </h4>
        </div>
        <div id="Kmom05" class="panel-collapse collapse">
            <div class="panel-body">
                    <ul>


                   </ul>
            </div>
        </div>
    </div>

    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title">
            <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom06">Kmom06</a>
            </h4>
        </div>
        <div id="Kmom06" class="panel-collapse collapse">
            <div class="panel-body">
                    <ul>
                        <li><b>Hur väl har du fått ordning på begreppen kring klient och server?</b></li>
                        Det har känts rätt klockrent från början egentligen. Jag jobbar ju med både klienter och servrar på heltid annars, så begreppet känns rätt klart för mig.
                        Jag kan dock förstå att det kan tänkas vara lite krångligt för personer som inte är fullt insatta i utveckling som tänker att det endast handlar
                        om att utveckla på klient-sidan. Speciellt när det gäller JavaScript! :)
                        Det har varit riktigt kul att jobba lite mer med NodeJS på servern, dock. Sett fram emot detta rätt ordentligt, faktiskt. Så det har känts bra och
                        funkat rätt bra! :)

                        <li><b>Hur känns det att utveckla i Node.js och den asynkrona programmeringsmodellen?</b></li>
                        Jadu, det känns rätt bra egentligen. Det mesta som körts har ju ändå varit rätt synkront egentligen. Inget som har varit ordentligt nytt enligt mig egentligen.
                        Det blev ju överlag ganska sekventiellt ändå! :)
                        Men att jobba asynkront är definitvt kul. Synd bara att det inte riktigt är möjligt att jobba med fler trådar. Känns som 'asynkron' programmering i
                        NodeJS är lite 'fulsälj' egentligen, då det egentligen handlar om att sätta upp 'flaggor' i serverns minne med hjälp av typ 'promises' så att
                        flow-staten (eller vad mna vill kalla den..) kan nås vid senare tillfällen. Jag hade ju gärna sett att mna kunde programera med lite fler trådar osv! :)

                        <li><b>Gick det bra med dina CLI-program i Node.js, några reflektioner kring dem?</b></li>
                        Jodå, det gick bra. Jag kan ju knappast säga att jobba i CLI är något som jag aldrig gjort förut, så det kändes rätt klockrent detta också.
                        Efter Python-kursen så är det ju nästan second-to-nature egentligen. Riktigt kul att se hur man kan skapa en CLI för NodeJS för att hantera
                        klient-sidan och styra upp kontakten med servern, dock! Det var riktigt kul!
                        Det svåra, enligt mig, med denna uppgiften var att jobba med AI:n och att hantera vinst-förhållandena! :)

                        <li><b>Gjorde du något extra i uppgiften, eller förändrade grundkoden i Gomoku-spelet?</b></li>
                        Yes, jag gjorde samtliga i uppgiften, men har inte 'förberett mig för Gomocup', dock tänker jag helt klart göra det - fast i ett annat språk.
                        Känns inte riktigt helt nödvändigt att skapa en AI inom JS, enligt mig då. Mycket för att det går att vara betydligt mer energisnål med andra språk,
                        vilket verkar vara grundtanken kring GomoCup (att skapa en AI som klarar av att göra beslut även med väldigt lite minne och prestanda).
                        <br>
                        Sen skrev jag ingen kod för den tredje uppgiften <b>"Om du hade byggt ut servern så att den styr upp klienterna så att de bara kan lägga om det är deras tur, samt stödja flera spel samtidigt. Hur hade du då gjort? Förklara i redovisningstexten, eller skriv koden för det."</b>
                        <br>
                        Dock skulle jag gärna vilja förklara hur jag hade löst det. Först och främst hade jag gjort som vi gjorde i förra kursmomentet där vi allokerade en spelare ett ID
                        fast i detta fall skulle ID:t vara allokerat till ett spel. Så man startar alltså med att skicka en /init/ till servern som skickar tillbaka en request med ditt spels ID.
                        Sen har man även ett ID för var spelare, så att man inte kan spela på sin gång. Så en curl-request till servern kan alltså se ut så här:
                        <br>
                        /gameid/playerid/place/x/y
                        <br>
                        Där gameid är ditt spels id (ett längre nummer som 18394), playerid är ditt spelarid (antingen 1 eller 2) och place/x/y som spelet specificerat.
                        PlayerID fungerar alltså som en slags flagga för att säkerställa att det är rätt spelares tur. Så här kan en mer konkret request se ut:
                        <br>
                        /18394/1/place/3/5
                        <br>
                        Så när denna request skickats så ändras en flagga i serverns flow-state för att säkerställa att nästa spelare är player 2. Om jag försöker skicka en
                        till request så säger den alltså ifrån, eftersom min klient blivit allokerad player 2. Som ni kanske förstår är detta int ehelt säkert, så det finns risk för
                        fusk utifall du exempelvis skickar en manuell curl-request. Om man vill ha det mer säkert så kan man allokera ett spelarid (längre sträng)
                        som är associerad med en IP eller inlogg. På så vis kan man koppla upp sig med sitt spelarid till servern och så får servern hantera vilket spelares tur det
                        är.

                        <br>
                        <br>
                        När det gäller koden i GomokuBoard är rätt mycket kod ändrad. Randomfunktionen använder sig av en rätt simpel algoritm som söker sig igenom hela brädet
                        för att hitta en ruta som är ledig samt har högst poäng. Poängen räknas ut genom att 'peeka' på de närliggande rutorna, om en ruta exempelvis har
                        samma markering som spelaren som randomizar så får rutan +2 poäng, om det är moståndarens ruta så får rutan +1 poäng. Sen fortsätter algoritmen att peeka
                        till nästa ruta för att se utifall rutan är av samma form som den tidigare, isf så inkrementeras poängen. Alltså om du står på ruta 5, 5 så testas
                        alla närliggande rutor (4,5. 5,6. 5, 4. 5, 6). Säg att 4, 5 har X (och du är O), då får du alltså +1 poäng samt att algoritmen forstätter att gå uppåt tills den
                        stöter på en av dina (O) eller en tom ruta. För varje extra ruta som är O så får du alltså +1 poäng. På så vis så letar sig algoritmen sig fram för att hitta
                        en ruta som ligger nära många av dina eller fiendens rutor.
                        Inte är den alltför smart, men den funkar någorlunda...

                        När det gäller vinstförhållanden så letar algoritmen först från vänster till höger, sen från upp till ner och sist de två diagonalerna. Så om du har 5, 5 igen så tittar algoritmen
                        alltså från 0, 5 och fem steg åt höger för varje steg (0-5, 1-6, 2-7, 3-8, 4-9, 5-10) tills dess att den hittar en bricka som är ledig eller som tillhör fienden. För varje
                        bricka som är din så används en counter för att se utifall du har fem i rad, om du har fem i rad så vinner du. Algoritmen körs VARJE gång som du lagt ut en bricka och stoppar
                        spelet om du har fem i rad med ett vinstmeddelande. Detta gäller bägge spelarna!

                        <li><b>Känner du dig sugen, och redo, på att skriva en deltagare till Gomocup?</b></li>
                        Jo, men det gör jag! Det ska jag helt klart göra. Dock blir det nog i Python eller C++ samt så får jag ju faktiskt tänka lite mer på algoritmen.
                        Känns som att man kanske bör använda sig av någon mer konkret algoritm för att ens ha en minimal chans för att klara spelet.

                   </ul>
            </div>
        </div>
    </div>

    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title">
            <a data-toggle="collapse" data-parent="#redovisnings-grupp" href="#Kmom10">Kmom10</a>
            </h4>
        </div>
        <div id="Kmom10" class="panel-collapse collapse">
            <div class="panel-body">
                    <ul>

                        <h2> <b> Inledning </b> </h2>
                        <br>
                        Först och främst hittar ni all källkod här på <a href="https://github.com/Todai88/bth_linux"><b>BTH_linux på GitHub</b></a>.<br>
<<<<<<< HEAD
                        Ni kan även finna min server på min Digital Ocean droplet (som kommer stå på, utan att uppdateras efter inlämning) på: 178.62.110.17:1337. <br>
                        När ni testar på era maskiner ska nämnas att jag använder mig av miljövariabler för att definiera server och port. Dvs att OM du har <br>
                        LINUX_PORT och LINUX_SERVER satta redan, så kommer de att användas utifall du inte använder dig av --server och / eller --port. <br><br>
                        Jag har, där jag kunnat, implementart ES6 lösningar. Mer specifikt lösningar som implementerar pilfunktioner. Gärna med hjälp utav högre funktioner (filter, map...).<br>
=======
                        Jag har, där jag kunnat, implementart ES6 lösningar. Mer specifikt lösningar som implementerar pilfunktioner (=>). Gärna med hjälp utav högre funktioner (filter, map...).<br>
>>>>>>> 4ea76b5d41b436f0964e8f18bd02120fc8d84a61
                        Bash-scripten löste jag likt de tidigare kursmomenten, där det finns tillgång till hjälptext och versionsnummer. Det finns även i fallet av delmoment 6 tillgång till<br>
                        olika sätt att testa de olika funktionerna. Alla som tar någon form av input testas på tre olika sätt, en gång utan parameter (404 expected), en gång med en parameter som<br>
                        inte ger något ('xxxxx') och sist med en parameter där jag vet ger resultat. I de två senare fallen får man en responskod på 200, då vi vet om att sidan finns, men i det tidigare<br>
                        fallet ges som sagt inget resultat utan det ges istället en felkod.<br>
                        <br>
                        Det ska även nämnas att samtliga funktioner som tar en parameter kommer ge dig en 200, oavsett om det finns resultat eller ej. Dvs om du testar via klienten eller via URL så kommer<br>
                        du alltså få en 200 så länge parameter ges (ex: /room/view/id/xxxx). Det ges antingen då ett tomt resultat (om du kör via URL) eller ett felmeddelande (om du kör via klienten).<br>
                        <br>
                        <h4><b>Servern</b></h4>
                        <b><u>Servern är uppdelad i fyra .js-filer:</u></b> <br>
                        <b>index.js</b> (hanterar dina options; -v, -h, --develop. startar även servern)
                        <br>
<<<<<<< HEAD
                        <b>bthappen_server.js</b> (hanterar navigeringen från routes till logiken)
=======
                        <b>bthappen_server.js</b> (hanterar navigeringen från routes -> logiken)
>>>>>>> 4ea76b5d41b436f0964e8f18bd02120fc8d84a61
                        <br>
                        <b>server_logic.js</b> (hanterar då all logik, dvs allt som händer bakom scenerna.)
                        <br>
                        <b>router.js</b> (sist har vi alltså den redan definierade routes.js).
                        <br>
                        <h4><b>Klienten</b></h4>
                        <b><u>Klienten är uppdelad i två .js-filer:</u></b> <br>
                        <b>index.js</b> Här händer magin. JSON som skickas från routern till klienten parsas och skrivs ut enligt uppgiftsbeskrivningen.<br>
                        <b>BthappenClient.js</b> Här skickas mina HTTP-requests till servern och responsen skickas till index.js för att parsas.<br><br>
                        <hr>
                        <li><b> Delmomenten </b></li>
                        Här beskrivs hur jag löst delmomenten, mina tankar och mina reflektioner kring dem.<br><br>
                        <ol>
                            <li><u><b>Bash för att konvertera XLS till JSON</b></u></li>
                            Utförandet här är ju rätt simpelt. I början hade jag lite strul med UTF-8 teckenkodning och CLRF EOL.
                            Detta för att jag lyckades använda mig av excel istället för en mer *nix-baserad lösning.

                            <br><br>

                            När jag märkte detta så använde jag mig av Google Sheets. Detta löste bägge problemen ovan <br>
                            och jag kunde därmed börja lösa uppgiften. <br>
                            Utöver detta så var det rätt lätt att lösa uppgiften. Vi har ju nu tillgång till jq, vilket gör<br>
                            att det är lättare att få ut information ur JSON-objekt. Dessutom så kommer det väl till hand <br>
                            när man ska skapa JSON-objekt baserat på .CSV eller andra filer.<br>
                            <br>
                            Jag löste detta genom att först köra en split på antingen \n eller \r (alltså fungerar det på både <br>
                            UNIX och på Windows). Därefter så splittas raderna efter komman (,).<br>
                            En sådan lösning ger dig då tomma strängen "" på samtliga tomma värden, vilket inte är rätt enligt<br>
                            uppgiftsbeskrivningen.<br>
                            Det löste jag genom att istället för att spara min JSON-data i minnet och sedan använda mig av en <br>
                            RegEx lösning för att byta alla "" mot null.<br>
                            <br>
                            Det gav mig då en välparsad salar.json som både <i>ser</i> bra ut och som även valideras väl online.
                            <br><br>
                            <li><u><b>Server för att visa och söka bland salar</b></u></li>

                            Här skapas alltså servern (alla fyra filer nämnda ovan) för att hantera all logik som händer på <br>
                            server-sidan. I mitt fall så har jag då valt att bryta upp min logik i fyra olika moduler för att <br>
                            dels göra det lättare för mig att läsa och uppdatera filerna.

                            <br><br>

                            Jag har då en index-fil som hanterar samtliga samtliga routes (alla extrauppgifter) och options. <br>
                            När servern startas (via index) så importeras servern från bthappen_server. Servern fungerar <br>
                            som en slags mellanhand mellan routes och server_logik. I logik-filen så hanterar jag då min lista av <br>
                            objekt (tagna från salar.json) som ligger i minnet och väntas på att tas om hand. Logiken tar alltså <br>
                            ut objekten, filtrerar dem enligt beskrivning och skickar dem till servern. När servern får dem <br>
                            så skapas mina HTTP-responses i form av JSON-arrayer eller listor av JSON-objekt (beroende på uppgift). <br>
                            <br>

                            Detta var väl delen av uppgiften som tog längst tid att få att fungera rent dynamiskt. Inte var det särskilt<br>
                            svårt, men det tog helt enkelt tid att felsöka problem som man stötte på. Speciellt då extrauppgifterna <br>
                            la till extra lager som då krävde att man gjorde om vissa delar i servern för att göra den mer dynamisk. <br>
                            Riktigt kul delmoment, dock! :)
                            <br><br>

                            <li><b><u>Klient i Node.js för att testköra mot servern</u></b></li>
                            Här börjar det roliga egentligen (om man tycker det är kul att debugga i cygwin...). -.- <br>
                            Klienten har då även alla extrauppgifter implementerade (searchp och --develop). <br>
                            Detta delmoment var nog det som tog minst tid egentligen. Här krävdes inget annat än en <br>
                            grundläggande förståelse för hur JSON-parsing fungerar. <br>
                            Det blev ju visserligen lite grötigare när man skulle implementera validering för att säkerställa <br>
                            att tomma paramterar inte skulle funger osv. Men det var ändå rätt grundläggande. <br>
                            <br>
                            Det ska dock nämnas att jag valt att hantera null, undefined och andra non-values på lite olika sätt.<br>
                            Jag vill alltså inte att de ska visas i klienten, utan visar specifikt utifall värden inte finns för <br>
                            nycklar i mina JSON-objekt. Lite pretty print, liksom. :)
                            <br><br>

                            <li><b><u>Bättre sökalgoritm (optionell)</u></b></li>

                            Här börjar det bli ordentligt kul! Låt mig börja med en tabell för att visa hur jag tänkt mig det skulle fungera:
                            <br><br>
                            <div class="container-fluid">
                                <div class="row">
                                    <div class="col-xs-3">
                                        <table>
                                            <tr>
                                                <th> Priority </th>
                                                <th> Points </th>
                                            </tr>
                                            <tr>
                                                <td> Salsnummer </td>
                                                <td> +25 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Salsnamn </td>
                                                <td> +20 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Lat, Lang </td>
                                                <td> +5 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Ort </td>
                                                <td> +10 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Hus </td>
                                                <td> +15 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Våning </td>
                                                <td> +10 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Typ </td>
                                                <td> +10 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Storlek </td>
                                                <td> +5 pts </td>
                                            </tr>
                                        </table>
                                    </div>
                                    <div class="col-xs-3">
                                        <table>
                                            <tr>
                                                <th> Träffyta </th>
                                                <th> Points </th>
                                            </tr>
                                            <tr>
                                                <td> Helträff </td>
                                                <td> +50 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Början av delsträng </td>
                                                <td> +30 pts </td>
                                            </tr>
                                            <tr>
                                                <td> Query finns i delsträng </td>
                                                <td> +10 pts </td>
                                            </tr>
                                        </table>
                                    </div>
                                </div>
                            </div>
                            <br>
                            Nu när du har en tabell att se på så kan jag gå igenom min angripsplan. <br>
                            Query skickas till servern som när man använder den normala sökningen, men <br>
                            till skillnad från den vanliga sökningen så används alltså en lite mer <br>
                            advancerad algoritm. <br>
                            <br>
                            1. Först söks samtliga nycklar igenom för att se om strängen finns i <br>
                            nyckelns värde. Med andra ord söks <u>ALLA</u> objekts nycklar igenom <br>
                            för att se utifal query-strängen finns (includes) i värdet. <br>
                            Om värdet finns så testas alltså träffytan. <br><br>
                            2. Testytan testas. Detta är rätt självförklarande. Jag ser alltså <br>
                            efter hur stor utav ytan som träffas. Är det en helträff? +50 pts <br>
                            Är det istället en träff på början av värdet (värdet.slice(0, query.length))?<br>
                            +30pts. <br>
                            Annars så VET vi ju redan att query-strängen finns i värdet. Då ges +10pts. <br>
                            <br>
                            Detta sker alltså på alla objekts värden i min lista av objekt. Så innan <br>
                            min algoritm går från objekt 0 till objekt 1 så vill jag ju självklart <br>
                            få ut det högsta värdet ur objekt 0 för att säkerställa en korrekt filtrering. <br>
                            Detta skapar en två-dimensionel lista med ett nummer för varje nyckel i varje <br>
                            objekt (Salsnr, salsnamn etc). <br>
                            Det säkerställer att jag VET vilken nyckel som har det högsta prioriteringen.<br><br>
                            <u>Exempel:</u> <br>
                            <b>Query:</b> c. <br>
                            <b>Objekt:</b> <br>
                            {<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Salsnr": "C236", <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Salsnamn": null, <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Lat": null, <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Long": null, <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Ort": "Karlskrona", <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Hus": "C-huset", <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Våning": "2", <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Typ": "Föreläsningssal", <br>
                                &nbsp;&nbsp;&nbsp;&nbsp;"Storlek": "30" <br>
                            }
                            <br><br>
                            Då skapas alltså en tvådimensionell lista som sådan:<br>
                            [   ['Salsnr', 55], ['Salsnamn', 0], ['Lat', 0], ['Long', 0], ['Ort', 0], ['Hus', 45], ['Våning', 0], ['Typ', 0], ['Storlek', 0]    ] <br>
                            Eftersom salsnummer ger +25 och detta salsnummer startar med 'c' så ges alltså +30. Detta ger högtsa nummret = 55pts. <br>
                            Detta skickas sen tillbaka med min array av filtrerade objekt så man får lite mer meta-data. Schysst, va? :) <br>

                            <br>
                            Självklart så skickas endast objekt som har någon slags poäng tillbaka (alltså inget med 0 poäng) och dessa är då sorterade med <br>
                            de högsta överst. I mitt fall så skickas 'searchp' tillbaka som stringifierade objekt istället för JSON-objekt. <br>
<<<<<<< HEAD
                            <br>
                            <li><u><b>Filtrera antalet träffar (Optionell)</b></u></li>
                            Denna uppgift var ju öppen för en hel del möjliga lösningar. Man kunde välja att endast hantera filtreringen <br>
                            på servern eftersom det inte stod något om att man behövde hantera någon slags filtrering på klientsidan. <br>
                            <br>
                            Dock så har jag valt att göra det möjligt att filtrera via klienten, via URL och filtreringen sköts helt och <br>
                            hållet på servern, vilket minskar belastningen på klienten. Detta kanske inte är något stort egentligen, men <br>
                            det gör det betydligt bättre för mig som tänker utveckla en front-end för servern i form av en mobil-app. <br>
                            Då vill man ju lägga så lite fokus på klienten som möjligt och istället hålla fokus på servern då den antagligen <br>
                            har lite mer processorkraft. Alltså får man lite mindre lagg på klienten. <br><br>

                            Om man vill filtrera via klienten så fungerar det på samtliga relevanta routes. Dvs alla förutom ID (ID är ju <br>
                            unikt ändå!). <br>
                            Detta löser man helt enkelt med att köra sitt kommando som vanligt, men med alternativet max och nummret. <br>
                            Exempelvis: <b>searchp karlskrona max 1</b> för att få ut det högst prioriterade (max 1) objektet med nyckelordet <br>
                            'karlskrona'.<br>
                            Man kan ju även göra detta via url:en genom att köra <b>room/searchp/karlskrona?max=1</b>. Bägge fungerar fint och <br>
                            har testats rätt ordentligt av mig och mina testcases i delmoment 6.<br>
                            <br>

                            Det ska alltså nämnas att jag gått lite längre än uppgiftsbeskrivningen som inte kräver att man ska kunna lösa <br>
                            filtreringen på klienten. Det krävs inte heller någon filtrering på searchp i uppgiftsbeskrivnignen, vilket jag gjort.<br>

                            <br><br>

                            Filtreringen i sig är rätt simpel. Jag skär helt enkelt bort de högsta n (där n är max's värde) objekten i listan genom <br>
                            att använda sig av en array.slice(0, max) om max är definierad i parameterna.
                            <br>
                            Endast nummer används, så utifall du skickar in en tom sträng så skippas filtreringen. Samma gäller ett icke-numrärt värde.
                            <br><br>

                            <li><b><u>Bättre testmöjligheter (optionell)</u></b></li>
                            Här går jag än en gång lite längre än vad uppgiftsbeksrivningen kräver. <br>
                            Målet här är alltså att skapa en --develop option på server och klient. På servern ska då ens JSON-respons visas. <br>
                            Detta enligt vad Emil Folino nämnt till mig. <br>
                            På klienten så ska URL:en som man använder för att skicka HTTP-requests visas, vilket är rätt lätt att lösas. I <br>
                            mitt fall så har jag gått lite längre och även visar serverns Response-Code för att säkerställa att användaren vet <br>
                            vad som händer.

                            <br><br>

                            Den sista biten är att skapa ett test-script som kör ett gäng definierade tester mot den servern som är definierad via <br>
                            dina miljövariabler. Om ingen server / port är definierad så defaultar den till localhost och 1337, precis som tidigare. <br>
                            Här ska även nämnas att jag tillämpat individuella tester på varje route samt ett test som kör samtliga tester. <br>
                            Det finns även en hjälptext som man kan köra via "bash test.bash --help". Enligt kravet så stödjs även --verbose <br>
                            för att skriva ut det svar som kommer i Response-Body, inte bara statuskoden. <br>
                            <br>
                            Ni kan alltså använda er av testet för att testa individuella routes: <br>
                            $bash test.bash list <br>
                            $$Ger er statuskoden på ett anrod (cURL) på listan (/room/list). <br>
                            Eller om ni vill köra alla så kör ni helt enkelt:<br>
                            $bash test.bash all<br>
                            <br>
                            Samtliga val stödjer alltså --verbose.
                            <br><br>
                            <hr>
                            <p class="lead strong"> Där har ni alltså mitt projekt. Förhoppningsvis så var det, samt redovisningstexten bra nog! :)<br>
                            Jag ber så hemskt mycket om ursäkt för den sena inlämningen, men jag tappade helt enkelt bort tiden. <br>
                            Jag har försökt lösa ett par personliga bekymmer och har varit hem till Sverige på begravning under helgen <br>
                            förra veckan (16/03 - 20/03).</p><br><br>
                        </ol>

                        <li><b> Reflektioner kring projektet </b></li>

                        Överlag så var det ett väl genomtänkt projekt där vi arbetade med många av sakerna som vi löste i tidigare kursmoment <br>
                        Dock finns det ju självklart saker som kanske kunde gjorts bättre. Dels kan jag tycka att de optionella delmomenten var <br>
                        rätt lätta; det sagt så tog de tid att göra. Så det är ju helt klart värt att notera att delmomenten i projektet tog <br>
                        tid att genomföra, speciellt om man vill felsöka sin kod manuellt (som jag föredrar att göra). <br>
                        <br>
                        Sen ogillade jag inte riktigt att mycket av koden kunde återanvändas mellan moduler och delmoment. <br>
                        Det kanske bara var jag som såg till att lösa mina funktioner på ett dynamiskt vis, vilket alltså <br>
                        kan ha gjort det lättare för mig ju längre in i projektet jag kom. Men jag kan inte skaka av mig <br>
                        känslan att man speciellt i de optionella delmomenten kunde återanvända sig av rätt mycket kod. <br>
                        Exempelvis filtreringen (max) kunde lösas inom ett par minuter genom att helt enkelt skicka in en <br>
                        liten optionell variabel till sina GET-funktioner.
                        <br><br>
                        Men som nämnt ovan känner jag att projektet var bra utifrån vad vi lärde oss tidigare i kursen. <br>
                        Det som jag kanske saknar är väl mer bash. Självklart förstår jag ju att bash är ett betydligt <br>
                        mindre eftersökt språk, men det känns ändå som att bash användes betydligt mycket mer i <br>
                        delmomenten än vad man kan se i projektet. <br>
                        Annars var det väldigt välutformat och genomtänkt.

                        <br><br>

                        Det var inget som var speciellt svårt, som sagt. Men vissa saker tog väl mer tid än andra. <br>
                        Som nämnt i mina beskrivningar ovan så kan ni ju se att mycket av min tid lades till att <br>
                        få min server att fungera väl. När den väl var uppe och rullade så var det inte så mycket <br>
                        mer som behövdes lösas än att man skulle parsa JSON-objekten och printa dem till skärmen.
                        <br><br>

                        Jag får även referrera till mina redovisningar på delmomenten, då det inte finns så mycket mer <br>
                        att säga.
                        <br><br>

                        <li><b> Reflektioner kring kursen </b></li>
                        Här kan det ju bli lite värre, dock. Kursen har överlag varit väldigt bra, jag uppskattade verkligen <br>
                        att lära mig mer om server-utveckling, då detta är något jag gör väldigt sällan. Det är ju även <br>
                        relevant för mig då jag velat lära mig mer om den delen pga. mina penetrationstest. <br>
                        <br>
                        Dock kan jag tycka att det kanske skulle ha varit smart att lägga mer energi på att lära ut mer vettiga <br>
                        sätt att hantera särskilda saker. Som exempel har vi ju jq och hur vi skulle parsa JSON-objekt i kursmomenten.<br>
                        Detta är ju egentligen inte ett större bekymmer, om jag ska vara helt ärlig. Men så mycket av det jag personligen <br>
                        tycker är bra med dessa db-kurser är att vi lär oss saker som är relevanta inom industrin just nu. <br>
                        Och det är överlag inte relevant för en framtida arbetsgivare att se utifall du kan parsa csv objekt, <br>
                        men det är istället väldigt intressant att se utifall du kan parsa JSON-objekt.
                        <br><br>
                        Självklart förstår jag att det finns flertalet studenter som inte vet hur man parsar JSON-objekt. <br>
                        Men nog kan vi väl åtminstone ha i åtanke att installera våra servrar med saker som faktiskt anses <br>
                        vara best practice inom industrin? <br>

                        <br>
                        Nu har ju iof jq blivit introducerat till servrarna, vilket hjälpte under sista delmomentet för oss <br>
                        som vill lära oss något nytt och vill jobba mot att lära oss något som är relevant på den moderna marknaden.<br>
                        Detta gillar jag skarpt, att det tog ett par dagar för er att ta till vara feedbacken som jag gav. <br>
                        Jag kan inte säga att jag är överdrivet nöjd med kursen, men det har egentligen bara varit det problemet <br>
                        som jag faktiskt haft.
                        <br><br>
                        Så kursen får en klar 7/10 denna gång. Det finns saker att tänka på, men överlag var det bra jobbat! :)
=======
                        </ol>

>>>>>>> 4ea76b5d41b436f0964e8f18bd02120fc8d84a61
                   </ul>
            </div>
        </div>
    </div>

    	</div>
    	</div>

<script type="text/javascript" src="js/main.js"></script>
</body>
</html>
